import * as eta from 'eta';
import * as lodash from 'lodash';
import * as swagger_schema_official from 'swagger-schema-official';

declare class NameResolver {
  reservedNames = [];
  getFallbackName = null;

  /** @type {CodeGenConfig} */
  config;
  /** @type {Logger} */
  logger;

  /**
   * @param {CodeGenConfig} config;
   * @param {Logger} logger;
   * @param {string[]} reservedNames
   */
  constructor(config, logger, reservedNames, getFallbackName) {
    this.config = config;
    this.logger = logger;
    this.getFallbackName = getFallbackName;
    this.reserve(reservedNames);
  }

  /**
   * @param {string[]} names
   */
  reserve(names) {
    const fixedNames = _.uniq(_.compact(names));
    for (const name of fixedNames) {
      if (this.reservedNames.indexOf(name) === -1) {
        this.reservedNames.push(name);
      }
    }
  }

  unreserve(names) {
    this.reservedNames.filter(
      (reservedName) => !names.some((name) => name === reservedName),
    );
  }

  isReserved(name) {
    return _.some(this.reservedNames, (reservedName) => reservedName === name);
  }

  /**
   *
   * @param {(string[])} variants
   * @param {(reserved: string[]) => string)} [resolver]
   * @param {any} [extras]
   * @returns {string | null}
   */
  resolve(variants, resolver, extras, shouldReserve = true) {
    if (typeof resolver === "function") {
      let usageName = null;
      while (usageName === null) {
        const variant = resolver(variants, extras);

        if (variant === undefined) {
          this.logger.warn(
            "unable to resolve name. current reserved names: ",
            this.reservedNames,
          );
          return null;
        }
        if (!shouldReserve || !this.isReserved(variant)) {
          usageName = variant;
        }
      }

      shouldReserve && this.reserve([usageName]);
      return usageName;
    } else if (Array.isArray(variants)) {
      let usageName = null;
      const uniqVariants = _.uniq(_.compact(variants));

      _.forEach(uniqVariants, (variant) => {
        if (!usageName && (!shouldReserve || !this.isReserved(variant))) {
          usageName = variant;
        }
      });

      if (usageName) {
        shouldReserve && this.reserve([usageName]);
        return usageName;
      }

      this.logger.debug(
        "trying to resolve name with using fallback name generator using variants",
        variants,
      );
      return this.resolve(variants, this.getFallbackName, extras);
    }

    this.logger.debug(
      "problem with reserving names. current reserved names: ",
      this.reservedNames,
    );
    return null;
  }
}

declare class ComponentTypeNameResolver extends NameResolver {
  counter = 1;
  fallbackNameCounter = 1;
  countersByVariant = new Map();

  /**
   * @param {CodeGenConfig} config;
   * @param {Logger} logger;
   * @param {string[]} reservedNames
   */
  constructor(config, logger, reservedNames) {
    super(config, logger, reservedNames, (variants) => {
      const randomVariant = variants[getRandomInt(0, variants.length - 1)];
      if (randomVariant) {
        if (!this.countersByVariant.has(randomVariant)) {
          this.countersByVariant.set(randomVariant, 0);
        }
        const variantCounter = this.countersByVariant.get(randomVariant) + 1;
        this.countersByVariant.set(randomVariant, variantCounter);
        const dirtyResolvedName = `${randomVariant}${variantCounter}`;
        this.logger.debug(
          "generated dirty resolved type name for component - ",
          dirtyResolvedName,
        );
        return dirtyResolvedName;
      }

      const fallbackName = `${this.config.componentTypeNameResolver}${this
        .fallbackNameCounter++}`;
      this.logger.debug(
        "generated fallback type name for component - ",
        fallbackName,
      );
      return fallbackName;
    });
  }
}

declare class MonoSchemaParser {
  schema;
  typeName;
  schemaPath;

  /** @type {Logger} */
  logger;
  /** @type {SchemaParser} */
  schemaParser;
  /** @type {SchemaParserFabric} */
  schemaParserFabric;
  /** @type {TypeNameFormatter} */
  typeNameFormatter;
  /** @type {SchemaComponentsMap} */
  schemaComponentsMap;
  /** @type {SchemaUtils} */
  schemaUtils;
  /** @type {CodeGenConfig} */
  config;
  /** @type {SchemaFormatters} */
  schemaFormatters;

  constructor(schemaParser, schema, typeName = null, schemaPath = []) {
    this.schemaParser = schemaParser;
    this.schemaParserFabric = schemaParser.schemaParserFabric;
    this.logger = schemaParser.logger;
    this.schema = schema;
    this.typeName = typeName;
    this.typeNameFormatter = schemaParser.typeNameFormatter;
    this.schemaPath = schemaPath;
    this.schemaComponentsMap = this.schemaParser.schemaComponentsMap;
    this.schemaUtils = this.schemaParser.schemaUtils;
    this.config = this.schemaParser.config;
    this.schemaFormatters = this.schemaParser.schemaFormatters;
  }

  parse() {
    throw new Error("not implemented");
  }

  buildTypeNameFromPath = () => {
    return this.schemaUtils.buildTypeNameFromPath(this.schemaPath);
  };
}

declare class SchemaParser {
  /** @type {SchemaParserFabric} */
  schemaParserFabric;
  /** @type {CodeGenConfig} */
  config;
  /** @type {Logger} */
  logger;
  /** @type {SchemaComponentsMap} */
  schemaComponentsMap;
  /** @type {TypeNameFormatter} */
  typeNameFormatter;
  /** @type {SchemaFormatters} */
  schemaFormatters;
  /** @type {SchemaUtils} */
  schemaUtils;
  /** @type {TemplatesWorker} */
  templatesWorker;
  /** @type {SchemaWalker} */
  schemaWalker;

  typeName;
  schema;
  schemaPath = [];

  constructor(schemaParserFabric, { typeName, schema, schemaPath } = {}) {
    this.schemaParserFabric = schemaParserFabric;
    this.config = schemaParserFabric.config;
    this.logger = schemaParserFabric.logger;
    this.templatesWorker = schemaParserFabric.templatesWorker;
    this.schemaComponentsMap = schemaParserFabric.schemaComponentsMap;
    this.typeNameFormatter = schemaParserFabric.typeNameFormatter;
    this.schemaWalker = schemaParserFabric.schemaWalker;
    this.schemaFormatters = schemaParserFabric.schemaFormatters;
    this.schemaUtils = schemaParserFabric.schemaUtils;

    this.typeName = typeName || null;
    this.schema = schema;
    this.schemaPath = [...(schemaPath || [])];
  }

  _complexSchemaParsers = {
    [SCHEMA_TYPES.COMPLEX_ONE_OF]: (schema) => {
      const SchemaParser =
        this.config.schemaParsers.complexOneOf || OneOfSchemaParser;
      const schemaParser = new SchemaParser(
        this,
        schema,
        null,
        this.schemaPath,
      );
      return schemaParser.parse();
    },
    [SCHEMA_TYPES.COMPLEX_ALL_OF]: (schema) => {
      const SchemaParser =
        this.config.schemaParsers.complexAllOf || AllOfSchemaParser;
      const schemaParser = new SchemaParser(
        this,
        schema,
        null,
        this.schemaPath,
      );
      return schemaParser.parse();
    },
    [SCHEMA_TYPES.COMPLEX_ANY_OF]: (schema) => {
      const SchemaParser =
        this.config.schemaParsers.complexAnyOf || AnyOfSchemaParser;
      const schemaParser = new SchemaParser(
        this,
        schema,
        null,
        this.schemaPath,
      );
      return schemaParser.parse();
    },
    [SCHEMA_TYPES.COMPLEX_NOT]: (schema) => {
      const SchemaParser =
        this.config.schemaParsers.complexNot || NotSchemaParser;
      const schemaParser = new SchemaParser(
        this,
        schema,
        null,
        this.schemaPath,
      );
      return schemaParser.parse();
    },
  };

  _baseSchemaParsers = {
    [SCHEMA_TYPES.ENUM]: (schema, typeName) => {
      const SchemaParser = this.config.schemaParsers.enum || EnumSchemaParser;
      const schemaParser = new SchemaParser(
        this,
        schema,
        typeName,
        this.schemaPath,
      );
      return schemaParser.parse();
    },
    [SCHEMA_TYPES.OBJECT]: (schema, typeName) => {
      const SchemaParser =
        this.config.schemaParsers.object || ObjectSchemaParser;
      const schemaParser = new SchemaParser(
        this,
        schema,
        typeName,
        this.schemaPath,
      );
      return schemaParser.parse();
    },
    [SCHEMA_TYPES.COMPLEX]: (schema, typeName) => {
      const SchemaParser =
        this.config.schemaParsers.complex || ComplexSchemaParser;
      const schemaParser = new SchemaParser(
        this,
        schema,
        typeName,
        this.schemaPath,
      );
      return schemaParser.parse();
    },
    [SCHEMA_TYPES.PRIMITIVE]: (schema, typeName) => {
      const SchemaParser =
        this.config.schemaParsers.primitive || PrimitiveSchemaParser;
      const schemaParser = new SchemaParser(
        this,
        schema,
        typeName,
        this.schemaPath,
      );
      return schemaParser.parse();
    },
    [SCHEMA_TYPES.DISCRIMINATOR]: (schema, typeName) => {
      const SchemaParser =
        this.config.schemaParsers.discriminator || DiscriminatorSchemaParser;
      const schemaParser = new SchemaParser(
        this,
        schema,
        typeName,
        this.schemaPath,
      );
      return schemaParser.parse();
    },
    [SCHEMA_TYPES.ARRAY]: (schema, typeName) => {
      const SchemaParser = this.config.schemaParsers.array || ArraySchemaParser;
      const schemaParser = new SchemaParser(
        this,
        schema,
        typeName,
        this.schemaPath,
      );
      return schemaParser.parse();
    },
  };

  /**
   * @return {Record<string, any>}
   */
  parseSchema = () => {
    if (!this.schema)
      return this._baseSchemaParsers[SCHEMA_TYPES.PRIMITIVE](
        null,
        this.typeName,
      );

    let schemaType = null;
    let parsedSchema = null;

    if (typeof this.schema === "string") {
      return this.schema;
    }

    if (!this.schema.$parsed) {
      if (!this.typeName && this.schemaUtils.isRefSchema(this.schema)) {
        this.typeName = this.schemaUtils.getSchemaType(this.schema);
      }

      //#region swagger schemas fixes

      // schema has items but don't have array type
      if (
        this.schema.items &&
        !Array.isArray(this.schema.items) &&
        !this.schema.type
      ) {
        this.schema.type = SCHEMA_TYPES.ARRAY;
      }
      // schema is enum with one null value
      if (
        Array.isArray(this.schema.enum) &&
        this.schema.enum.length === 1 &&
        this.schema.enum[0] == null
      ) {
        this.logger.debug("invalid enum schema", this.schema);
        this.schema = { type: this.config.Ts.Keyword.Null };
      }
      // schema is response schema
      if ("content" in this.schema && typeof this.schema.content === "object") {
        const schema = this.extractSchemaFromResponseStruct(this.schema);
        const schemaParser = this.schemaParserFabric.createSchemaParser({
          schema,
          typeName: this.typeName,
          schemaPath: this.schemaPath,
        });
        this.schema.$parsed = schemaParser.parseSchema();
        return this.schema.$parsed;
      }

      //#endregion

      schemaType = this.schemaUtils.getInternalSchemaType(this.schema);

      this.schemaPath.push(this.typeName);

      _.merge(
        this.schema,
        this.config.hooks.onPreParseSchema(
          this.schema,
          this.typeName,
          schemaType,
        ),
      );
      parsedSchema = this._baseSchemaParsers[schemaType](
        this.schema,
        this.typeName,
      );
      this.schema.$parsed =
        this.config.hooks.onParseSchema(this.schema, parsedSchema) ||
        parsedSchema;

      if (
        this.config.sortTypes &&
        Array.isArray(this.schema.$parsed?.content)
      ) {
        this.schema.$parsed.content = this.schema.$parsed.content.sort(
          sortByProperty("name"),
        );
      }
    }

    this.schemaPath.pop();

    return this.schema.$parsed;
  };

  getInlineParseContent = () => {
    const parsedSchema = this.parseSchema();
    const formattedSchema = this.schemaFormatters.formatSchema(
      parsedSchema,
      "inline",
    );
    return formattedSchema.content;
  };

  getParseContent = () => {
    const parsedSchema = this.parseSchema();
    const formattedSchema = this.schemaFormatters.formatSchema(
      parsedSchema,
      "base",
    );
    return formattedSchema.content;
  };

  extractSchemaFromResponseStruct = (responseStruct) => {
    const { content, ...extras } = responseStruct;

    const firstResponse = _.first(_.values(content));
    const firstSchema = _.get(firstResponse, "schema");

    if (!firstSchema) return;

    return {
      ...extras,
      ..._.omit(firstResponse, "schema"),
      ...firstSchema,
    };
  };
}

/**
 * @typedef {{ fileName: string, fileExtension: string, fileContent: string }} TranslatorIO
 */

declare class Translator {
  /** @type {Logger} */
  logger;
  /** @type {CodeGenConfig} */
  config;
  /** @type {CodeFormatter} */
  codeFormatter;

  /**
   * @param codeGenProcess
   */
  constructor(codeGenProcess) {
    this.logger = codeGenProcess.logger;
    this.config = codeGenProcess.config;
    this.codeFormatter = codeGenProcess.codeFormatter;
  }

  /**
   *
   * @param input {TranslatorIO}
   * @return {Promise<TranslatorIO[]>}
   */
  // eslint-disable-next-line no-unused-vars
  translate(input) {
    throw new Error("not implemented");
  }
}

declare class CodeGenProcess {
  /** @type {CodeGenConfig} */
  config;
  /** @type {SwaggerSchemaResolver} */
  swaggerSchemaResolver;
  /** @type {SchemaComponentsMap} */
  schemaComponentsMap;
  /** @type {Logger} */
  logger;
  /** @type {TypeNameFormatter} */
  typeNameFormatter;
  /** @type {SchemaParserFabric} */
  schemaParserFabric;
  /** @type {SchemaRoutes} */
  schemaRoutes;
  /** @type {FileSystem} */
  fileSystem;
  /** @type {CodeFormatter} */
  codeFormatter;
  /** type {TemplatesWorker} */
  templatesWorker;
  /** @type {SchemaWalker} */
  schemaWalker;
  /** @type {JavascriptTranslator} */
  javascriptTranslator;

  /**
   *
   * @param config {Partial<import("../index.d.ts").GenerateApiConfiguration['config']>}
   */
  constructor(config) {
    this.config = new CodeGenConfig(config);
    this.logger = new Logger(this);
    this.fileSystem = new FileSystem(this);
    this.schemaWalker = new SchemaWalker(this);
    this.swaggerSchemaResolver = new SwaggerSchemaResolver(this);
    this.schemaComponentsMap = new SchemaComponentsMap(this);
    this.typeNameFormatter = new TypeNameFormatter(this);
    this.templatesWorker = new TemplatesWorker(this);
    this.codeFormatter = new CodeFormatter(this);
    this.schemaParserFabric = new SchemaParserFabric(this);
    this.schemaRoutes = new SchemaRoutes(this);
    this.javascriptTranslator = new JavascriptTranslator(this);
    this.config.componentTypeNameResolver.logger = this.logger;
  }

  async start() {
    this.config.update({
      templatePaths: this.templatesWorker.getTemplatePaths(this.config),
    });
    this.config.update({
      templatesToRender: this.templatesWorker.getTemplates(this.config),
    });

    const swagger = await this.swaggerSchemaResolver.create();

    this.swaggerSchemaResolver.fixSwaggerSchema(swagger);

    this.config.update({
      swaggerSchema: swagger.usageSchema,
      originalSchema: swagger.originalSchema,
    });

    this.schemaWalker.addSchema("$usage", swagger.usageSchema);
    this.schemaWalker.addSchema("$original", swagger.originalSchema);

    this.logger.event("start generating your typescript api");

    this.config.update(
      this.config.hooks.onInit(this.config, this) || this.config,
    );

    this.schemaComponentsMap.clear();

    _.each(swagger.usageSchema.components, (component, componentName) =>
      _.each(component, (rawTypeData, typeName) => {
        this.schemaComponentsMap.createComponent(
          this.schemaComponentsMap.createRef([
            "components",
            componentName,
            typeName,
          ]),
          rawTypeData,
        );
      }),
    );

    /**
     * @type {SchemaComponent[]}
     */
    const componentsToParse = this.schemaComponentsMap.filter(
      _.compact(["schemas", this.config.extractResponses && "responses"]),
    );

    const parsedSchemas = componentsToParse.map((schemaComponent) => {
      const parsed = this.schemaParserFabric.parseSchema(
        schemaComponent.rawTypeData,
        schemaComponent.typeName,
      );
      schemaComponent.typeData = parsed;
      return parsed;
    });

    this.schemaRoutes.attachSchema({
      usageSchema: swagger.usageSchema,
      parsedSchemas,
    });

    const rawConfiguration = {
      apiConfig: this.createApiConfig(swagger.usageSchema),
      config: this.config,
      modelTypes: this.collectModelTypes(),
      hasSecurityRoutes: this.schemaRoutes.hasSecurityRoutes,
      hasQueryRoutes: this.schemaRoutes.hasQueryRoutes,
      hasFormDataRoutes: this.schemaRoutes.hasFormDataRoutes,
      generateResponses: this.config.generateResponses,
      routes: this.schemaRoutes.getGroupedRoutes(),
      extraTemplates: this.config.extraTemplates,
      fileName: this.config.fileName,
      translateToJavaScript: this.config.toJS,
      customTranslator: this.config.customTranslator
        ? new this.config.customTranslator(this)
        : null,
      utils: this.getRenderTemplateData().utils,
    };

    const configuration =
      this.config.hooks.onPrepareConfig(rawConfiguration) || rawConfiguration;

    if (this.fileSystem.pathIsExist(this.config.output)) {
      if (this.config.cleanOutput) {
        this.logger.debug(`cleaning dir ${this.config.output}`);
        this.fileSystem.cleanDir(this.config.output);
      }
    } else {
      this.logger.debug(
        `path ${this.config.output} is not exist. creating dir by this path`,
      );
      this.fileSystem.createDir(this.config.output);
    }

    const files = await this.generateOutputFiles({
      configuration: configuration,
    });

    const isDirPath = this.fileSystem.pathIsDir(this.config.output);

    if (isDirPath) {
      files.forEach((file) => {
        this.fileSystem.createFile({
          path: this.config.output,
          fileName: `${file.fileName}${file.fileExtension}`,
          content: file.fileContent,
          withPrefix: true,
        });

        this.logger.success(
          "api file",
          `"${file.fileName}${file.fileExtension}"`,
          `created in ${this.config.output}`,
        );
      });
    }

    return {
      files,
      configuration,
      getTemplate: this.templatesWorker.getTemplate,
      renderTemplate: this.templatesWorker.renderTemplate,
      createFile: this.fileSystem.createFile,
      formatTSContent: this.codeFormatter.formatCode,
    };
  }

  getRenderTemplateData = () => {
    return {
      utils: {
        Ts: this.config.Ts,
        formatDescription:
          this.schemaParserFabric.schemaFormatters.formatDescription,
        internalCase: internalCase,
        classNameCase: pascalCase,
        pascalCase: pascalCase,
        getInlineParseContent: this.schemaParserFabric.getInlineParseContent,
        getParseContent: this.schemaParserFabric.getParseContent,
        getComponentByRef: this.schemaComponentsMap.get,
        parseSchema: this.schemaParserFabric.parseSchema,
        checkAndAddNull: this.schemaParserFabric.schemaUtils.safeAddNullToType,
        safeAddNullToType:
          this.schemaParserFabric.schemaUtils.safeAddNullToType,
        isNeedToAddNull:
          this.schemaParserFabric.schemaUtils.isNullMissingInType,
        inlineExtraFormatters: this.schemaParserFabric.schemaFormatters.inline,
        formatters: this.schemaParserFabric.schemaFormatters.base,
        formatModelName: this.typeNameFormatter.format,
        fmtToJSDocLine: function fmtToJSDocLine(line, { eol = true }) {
          return ` * ${line}${eol ? "\n" : ""}`;
        },
        NameResolver: NameResolver,
        _,
        require: this.templatesWorker.requireFnFromTemplate,
      },
      config: this.config,
    };
  };

  collectModelTypes = () => {
    const components = this.schemaComponentsMap.getComponents();
    let modelTypes = [];

    const modelTypeComponents = _.compact([
      "schemas",
      this.config.extractResponses && "responses",
    ]);

    const getSchemaComponentsCount = () =>
      this.schemaComponentsMap.filter(...modelTypeComponents).length;

    let schemaComponentsCount = getSchemaComponentsCount();
    let processedCount = 0;

    while (processedCount < schemaComponentsCount) {
      modelTypes = [];
      processedCount = 0;
      for (const component of components) {
        if (modelTypeComponents.includes(component.componentName)) {
          const modelType = this.prepareModelType(component);
          if (modelType) {
            modelTypes.push(modelType);
          }
          processedCount++;
        }
      }
      schemaComponentsCount = getSchemaComponentsCount();
    }

    if (this.config.sortTypes) {
      return modelTypes.sort(sortByProperty("name"));
    }

    return modelTypes;
  };

  prepareModelType = (typeInfo) => {
    if (typeInfo.$prepared) return typeInfo.$prepared;

    if (!typeInfo.typeData) {
      typeInfo.typeData = this.schemaParserFabric.parseSchema(
        typeInfo.rawTypeData,
        typeInfo.typeName,
      );
    }
    const rawTypeData = typeInfo.typeData;
    const typeData = this.schemaParserFabric.schemaFormatters.base[
      rawTypeData.type
    ]
      ? this.schemaParserFabric.schemaFormatters.base[rawTypeData.type](
          rawTypeData,
        )
      : rawTypeData;
    let { typeIdentifier, name: originalName, content, description } = typeData;
    const name = this.typeNameFormatter.format(originalName);

    if (name === null) return null;

    const preparedModelType = {
      ...typeData,
      typeIdentifier,
      name,
      description,
      $content: rawTypeData.content,
      rawContent: rawTypeData.content,
      content: content,
      typeData,
    };

    typeInfo.$prepared = preparedModelType;

    return preparedModelType;
  };

  /**
   *
   * @param configuration
   * @returns {Promise<TranslatorIO[]>}
   */
  generateOutputFiles = async ({ configuration }) => {
    const { modular, templatesToRender } = this.config;

    const output = modular
      ? await this.createMultipleFileInfos(templatesToRender, configuration)
      : await this.createSingleFileInfo(templatesToRender, configuration);

    if (!_.isEmpty(configuration.extraTemplates)) {
      for (const extraTemplate of configuration.extraTemplates) {
        const content = this.templatesWorker.renderTemplate(
          this.fileSystem.getFileContent(extraTemplate.path),
          configuration,
        );
        output.push(
          ...(await this.createOutputFileInfo(
            configuration,
            extraTemplate.name,
            content,
          )),
        );
      }
    }

    return output.filter((fileInfo) => !!fileInfo && !!fileInfo.fileContent);
  };

  /**
   * @param templatesToRender
   * @param configuration
   * @returns {Promise<TranslatorIO[]>}
   */
  createMultipleFileInfos = async (templatesToRender, configuration) => {
    const { routes } = configuration;
    const { fileNames, generateRouteTypes, generateClient } =
      configuration.config;
    /**
     * @type {TranslatorIO[]}
     */
    const modularApiFileInfos = [];

    if (routes.$outOfModule) {
      if (generateRouteTypes) {
        const outOfModuleRouteContent = this.templatesWorker.renderTemplate(
          templatesToRender.routeTypes,
          {
            ...configuration,
            route: configuration.routes.$outOfModule,
          },
        );

        modularApiFileInfos.push(
          ...(await this.createOutputFileInfo(
            configuration,
            fileNames.outOfModuleApi,
            outOfModuleRouteContent,
          )),
        );
      }
      if (generateClient) {
        const outOfModuleApiContent = this.templatesWorker.renderTemplate(
          templatesToRender.api,
          {
            ...configuration,
            route: configuration.routes.$outOfModule,
          },
        );

        modularApiFileInfos.push(
          ...(await this.createOutputFileInfo(
            configuration,
            fileNames.outOfModuleApi,
            outOfModuleApiContent,
          )),
        );
      }
    }

    if (routes.combined) {
      for (const route of routes.combined) {
        if (generateRouteTypes) {
          const routeModuleContent = this.templatesWorker.renderTemplate(
            templatesToRender.routeTypes,
            {
              ...configuration,
              route,
            },
          );

          modularApiFileInfos.push(
            ...(await this.createOutputFileInfo(
              configuration,
              pascalCase(`${route.moduleName}_Route`),
              routeModuleContent,
            )),
          );
        }

        if (generateClient) {
          const apiModuleContent = this.templatesWorker.renderTemplate(
            templatesToRender.api,
            {
              ...configuration,
              route,
            },
          );

          modularApiFileInfos.push(
            ...(await this.createOutputFileInfo(
              configuration,
              pascalCase(route.moduleName),
              apiModuleContent,
            )),
          );
        }
      }
    }

    return [
      ...(await this.createOutputFileInfo(
        configuration,
        fileNames.dataContracts,
        this.templatesWorker.renderTemplate(
          templatesToRender.dataContracts,
          configuration,
        ),
      )),
      ...(generateClient
        ? await this.createOutputFileInfo(
            configuration,
            fileNames.httpClient,
            this.templatesWorker.renderTemplate(
              templatesToRender.httpClient,
              configuration,
            ),
          )
        : []),
      ...modularApiFileInfos,
    ];
  };

  /**
   *
   * @param templatesToRender
   * @param configuration
   * @returns {Promise<TranslatorIO[]>}
   */
  createSingleFileInfo = async (templatesToRender, configuration) => {
    const { generateRouteTypes, generateClient } = configuration.config;

    return await this.createOutputFileInfo(
      configuration,
      configuration.fileName,
      _.compact([
        this.templatesWorker.renderTemplate(
          templatesToRender.dataContracts,
          configuration,
        ),
        generateRouteTypes &&
          this.templatesWorker.renderTemplate(
            templatesToRender.routeTypes,
            configuration,
          ),
        generateClient &&
          this.templatesWorker.renderTemplate(
            templatesToRender.httpClient,
            configuration,
          ),
        generateClient &&
          this.templatesWorker.renderTemplate(
            templatesToRender.api,
            configuration,
          ),
      ]).join("\n"),
    );
  };

  /**
   *
   * @param configuration
   * @param fileNameFull
   * @param content
   * @returns {Promise<TranslatorIO[]>}
   */
  createOutputFileInfo = async (configuration, fileNameFull, content) => {
    const fileName = this.fileSystem.cropExtension(fileNameFull);
    const fileExtension = ts.Extension.Ts;

    if (configuration.translateToJavaScript) {
      this.logger.debug("using js translator for", fileName);
      return await this.javascriptTranslator.translate({
        fileName: fileName,
        fileExtension: fileExtension,
        fileContent: content,
      });
    }

    if (configuration.customTranslator) {
      this.logger.debug("using custom translator for", fileName);
      return await configuration.customTranslator.translate({
        fileName: fileName,
        fileExtension: fileExtension,
        fileContent: content,
      });
    }

    this.logger.debug("generating output for", `${fileName}${fileExtension}`);

    return [
      {
        fileName,
        fileExtension: fileExtension,
        fileContent: await this.codeFormatter.formatCode(content),
      },
    ];
  };

  createApiConfig = (swaggerSchema) => {
    const { info, servers, host, basePath, externalDocs, tags } = swaggerSchema;
    const server = servers?.[0] || { url: "" };
    const { title = "No title", version } = info || {};
    const { url: serverUrl } = server;

    return {
      info: info || {},
      servers: servers || [],
      basePath,
      host,
      externalDocs: _.merge(
        {
          url: "",
          description: "",
        },
        externalDocs,
      ),
      tags: _.compact(tags),
      baseUrl: serverUrl,
      title,
      version,
    };
  };

  injectClassInstance = (key, value) => {
    this[key] = value;
    PATCHABLE_INSTANCES.forEach((instanceKey) => {
      if (instanceKey !== key && key in this[instanceKey]) {
        this[instanceKey][key] = value;
      }
    });
  };
}

type HttpClientType = "axios" | "fetch";

interface GenerateApiParamsBase {
  /**
   * default 'api.ts'
   */
  name?: string;

  /**
   * name of the main exported class
   */
  apiClassName?: string;

  /**
   * path to folder where will be located the created api module.
   *
   * may set to `false` to skip writing content to disk. in this case,
   * you may access the `files` on the return value.
   */
  output?: string | false;

  /**
   * path to folder containing templates (default: ./src/templates)
   */
  templates?: string;

  /**
   * generate all "enum" types as union types (T1 | T2 | TN) (default: false)
   */
  generateUnionEnums?: boolean;

  /**
   * generate type definitions for API routes (default: false)
   */
  generateRouteTypes?: boolean;

  /**
   * do not generate an API class
   */
  generateClient?: boolean;
  /**
   * generated http client type
   */
  httpClientType?: HttpClientType;
  /**
   * use "default" response status code as success response too.
   * some swagger schemas use "default" response status code as success response type by default.
   */
  defaultResponseAsSuccess?: boolean;

  /**
   * generate additional information about request responses
   * also add typings for bad responses
   */
  generateResponses?: boolean;

  /**
   * unwrap the data item from the response
   */
  unwrapResponseData?: boolean;

  /**
   * sort data contracts in alphabetical order
   */
  sortTypes?: boolean;

  /**
   * sort routes in alphabetical order
   */
  sortRoutes?: boolean;

  /**
   * generate js api module with declaration file (default: false)
   */
  toJS?: boolean;

  /**
   * determines which path index should be used for routes separation
   */
  moduleNameIndex?: number;
  /**
   * users operation's first tag for route separation
   */
  moduleNameFirstTag?: boolean;
  /**
   * disabled SSL check
   */
  disableStrictSSL?: boolean;
  /**
   * disabled Proxy
   */
  disableProxy?: boolean;
  /**
   * generate separated files for http client, data contracts, and routes (default: false)
   */
  modular?: boolean;
  /**
   * extract request params to data contract (Also combine path params and query params into one object)
   */
  extractRequestParams?: boolean;
  /**
   * extract request body type to data contract
   */
  extractRequestBody?: boolean;
  /**
   * extract response body type to data contract
   */
  extractResponseBody?: boolean;
  /**
   * extract response error type to data contract
   */
  extractResponseError?: boolean;
  /**
   * prettier configuration
   */
  prettier?: object;
  /**
   * Output only errors to console (default: false)
   */
  silent?: boolean;
  /**
   * default type for empty response schema (default: "void")
   */
  defaultResponseType?: string;
  /**
   * Ability to send HttpClient instance to Api constructor
   */
  singleHttpClient?: boolean;
  cleanOutput?: boolean;
  enumNamesAsValues?: boolean;

  hooks?: Partial<Hooks>;
  /**
   *  extra templates
   */
  extraTemplates?: { name: string; path: string }[];

  /**
   * fix up small errors in the swagger source definition
   */
  patch?: boolean;
  /**
   *  authorization token
   */
  authorizationToken?: string;
  /**
   * generate readonly properties (default: false)
   */
  addReadonly?: boolean;

  primitiveTypeConstructs?: (
    struct: PrimitiveTypeStruct,
  ) => Partial<PrimitiveTypeStruct>;

  codeGenConstructs?: (struct: CodeGenConstruct) => Partial<CodeGenConstruct>;

  /** extract all enums from nested types\interfaces to `enum` construction */
  extractEnums?: boolean;

  /** prefix string value needed to fix invalid type names (default: 'Type') */
  fixInvalidTypeNamePrefix?: string;

  /** prefix string value needed to fix invalid enum keys (default: 'Value') */
  fixInvalidEnumKeyPrefix?: string;

  /** prefix string value for enum keys */
  enumKeyPrefix?: string;

  /** suffix string value for enum keys */
  enumKeySuffix?: string;

  /** prefix string value for type names */
  typePrefix?: string;

  /** suffix string value for type names */
  typeSuffix?: string;

  /** extra configuration for extracting type names operations */
  extractingOptions?: Partial<ExtractingOptions>;

  /** configuration for fetching swagger schema requests */
  requestOptions?: null | Partial<RequestInit>;

  /** ts compiler configuration object (for --to-js option) */
  compilerTsConfig?: Record<string, unknown>;

  /**
   * custom ts->* translator
   * do not use constructor args, it can break functionality of this property, just send class reference
   *
   * @example
   * ```ts
   * import { Translator } from "swagger-typescript-api/src/translators/translator";
   *
   * class MyTranslator extends Translator {
   *
   *     translate({ fileName, fileExtension, fileContent }) {
   *         this.codeFormatter.format()
   *         this.config.
   *         this.logger.
   *
   *         return [
   *             {
   *                 fileName,
   *                 fileExtension,
   *                 fileContent,
   *             }
   *         ]
   *     }
   * }
   * ```
   */
  customTranslator?: new () => typeof Translator;
  /** fallback name for enum key resolver */
  enumKeyResolverName?: string;
  /** fallback name for type name resolver */
  typeNameResolverName?: string;
  /** fallback name for specific arg name resolver */
  specificArgNameResolverName?: string;
  schemaParsers?: {
    complexOneOf?: MonoSchemaParser;
    complexAllOf?: MonoSchemaParser;
    complexAnyOf?: MonoSchemaParser;
    complexNot?: MonoSchemaParser;
    enum?: MonoSchemaParser;
    object?: MonoSchemaParser;
    complex?: MonoSchemaParser;
    primitive?: MonoSchemaParser;
    discriminator?: MonoSchemaParser;
    array?: MonoSchemaParser;
  };
}

type CodeGenConstruct = {
  Keyword: {
    Number: string;
    String: string;
    Boolean: string;
    Any: string;
    Void: string;
    Unknown: string;
    Null: string;
    Undefined: string;
    Object: string;
    File: string;
    Date: string;
    Type: string;
    Enum: string;
    Interface: string;
    Array: string;
    Record: string;
    Intersection: string;
    Union: string;
  };
  CodeGenKeyword: {
    UtilRequiredKeys: string;
  };
  ArrayType: (content: unknown) => string;
  StringValue: (content: unknown) => string;
  BooleanValue: (content: unknown) => string;
  NumberValue: (content: unknown) => string;
  NullValue: (content: unknown) => string;
  UnionType: (content: unknown) => string;
  ExpressionGroup: (content: unknown) => string;
  IntersectionType: (content: unknown) => string;
  RecordType: (content: unknown) => string;
  TypeField: (content: unknown) => string;
  InterfaceDynamicField: (content: unknown) => string;
  EnumField: (content: unknown) => string;
  EnumFieldsWrapper: (content: unknown) => string;
  ObjectWrapper: (content: unknown) => string;
  MultilineComment: (content: unknown) => string;
  TypeWithGeneric: (content: unknown) => string;
};

type PrimitiveTypeStructValue =
  | string
  | ((
      schema: Record<string, unknown>,
      parser: SchemaParser,
    ) => string);

type PrimitiveTypeStruct = Record<
  "integer" | "number" | "boolean" | "object" | "file" | "string" | "array",
  | string
  | ({ $default: PrimitiveTypeStructValue } & Record<
      string,
      PrimitiveTypeStructValue
    >)
>;

interface GenerateApiParamsFromPath extends GenerateApiParamsBase {
  /**
   * path to swagger schema
   */
  input: string;
}

interface GenerateApiParamsFromUrl extends GenerateApiParamsBase {
  /**
   * url to swagger schema
   */
  url: string;
}

interface GenerateApiParamsFromSpecLiteral extends GenerateApiParamsBase {
  /**
   * swagger schema JSON
   */
  spec: swagger_schema_official.Spec;
}

type GenerateApiParams =
  | GenerateApiParamsFromPath
  | GenerateApiParamsFromUrl
  | GenerateApiParamsFromSpecLiteral;

type BuildRouteParam = {
  /** {bar} */
  $match: string;
  name: string;
  required: boolean;
  type: "string";
  description: string;
  schema: {
    type: string;
  };
  in: "path" | "query";
};

type BuildRoutePath = {
  /** /foo/{bar}/baz */
  originalRoute: string;
  /** /foo/${bar}/baz */
  route: string;
  pathParams: BuildRouteParam[];
  queryParams: BuildRouteParam[];
};

interface Hooks {
  /** calls before parse\process route path */
  onPreBuildRoutePath: (routePath: string) => string | undefined;
  /** calls after parse\process route path */
  onBuildRoutePath: (data: BuildRoutePath) => BuildRoutePath | undefined;
  /** calls before insert path param name into string path interpolation */
  onInsertPathParam: (
    paramName: string,
    index: number,
    arr: BuildRouteParam[],
    resultRoute: string,
  ) => string | undefined;
  /** calls after parse schema component */
  onCreateComponent: (
    component: SchemaComponent,
  ) => SchemaComponent | undefined;
  /** calls before parse any kind of schema */
  onPreParseSchema: (
    originalSchema: unknown,
    typeName: string,
    schemaType: string,
  ) => undefined;
  /** calls after parse any kind of schema */
  onParseSchema: (
    originalSchema: unknown,
    parsedSchema: unknown,
  ) => unknown | undefined;
  /** calls after parse route (return type: customized route (ParsedRoute), nothing change (void), false (ignore this route)) */
  onCreateRoute: (routeData: ParsedRoute) => ParsedRoute | false | undefined;
  /** Start point of work this tool (after fetching schema) */
  onInit?: <C extends GenerateApiConfiguration["config"]>(
    configuration: C,
    codeGenProcess: CodeGenProcess,
  ) => C | undefined;
  /** customize configuration object before sending it to ETA templates */
  onPrepareConfig?: <C extends GenerateApiConfiguration>(
    currentConfiguration: C,
  ) => C | undefined;
  /** customize route name as you need */
  onCreateRouteName?: (
    routeNameInfo: RouteNameInfo,
    rawRouteInfo: RawRouteInfo,
  ) => RouteNameInfo | undefined;
  /** customize request params (path params, query params) */
  onCreateRequestParams?: (
    rawType: SchemaComponent["rawTypeData"],
  ) => SchemaComponent["rawTypeData"] | undefined;
  /** customize name of model type */
  onFormatTypeName?: (
    typeName: string,
    rawTypeName?: string,
    schemaType?: "type-name" | "enum-key",
  ) => string | undefined;
  /** customize name of route (operationId), you can do it with using onCreateRouteName too */
  onFormatRouteName?: (
    routeInfo: RawRouteInfo,
    templateRouteName: string,
  ) => string | undefined;
}

type RouteNameRouteInfo = Record<unknown, unknown>;

type RouteNameInfo = {
  usage: string;
  original: string;
  duplicate: boolean;
};

type SchemaTypePrimitiveContent = {
  $parsedSchema: boolean;
  schemaType: string;
  type: string;
  typeIdentifier: string;
  name?: unknown;
  description: string;
  content: string;
};

type SchemaTypeObjectContent = {
  $$raw: {
    type: string;
    required: boolean;
    $parsed: SchemaTypePrimitiveContent;
  };
  isRequired: boolean;
  field: string;
}[];

type SchemaTypeEnumContent = {
  key: string;
  type: string;
  value: string;
};

interface ParsedSchema<C> {
  $parsedSchema: boolean;
  schemaType: string;
  type: string;
  typeIdentifier: string;
  name: string;
  description?: string;
  allFieldsAreOptional?: boolean;
  content: C;
}

interface PathArgInfo {
  name: string;
  optional: boolean;
  type: string;
  description?: string;
}

interface SchemaComponent {
  $ref: string;
  typeName: string;
  rawTypeData?: {
    type: string;
    required?: string[];
    properties?: Record<
      string,
      {
        name?: string;
        type: string;
        required: boolean;
        $parsed?: SchemaTypePrimitiveContent;
      }
    >;
    discriminator?: {
      propertyName?: string;
    };
    $parsed: ParsedSchema<
      | SchemaTypeObjectContent
      | SchemaTypeEnumContent
      | SchemaTypePrimitiveContent
    >;
  };
  componentName: "schemas" | "paths";
  typeData: ParsedSchema<
    SchemaTypeObjectContent | SchemaTypeEnumContent | SchemaTypePrimitiveContent
  > | null;
}

declare enum RequestContentKind {
  JSON = "JSON",
  URL_ENCODED = "URL_ENCODED",
  FORM_DATA = "FORM_DATA",
  IMAGE = "IMAGE",
  OTHER = "OTHER",
  TEXT = "TEXT",
}

interface RequestResponseInfo {
  contentTypes: string[];
  contentKind: RequestContentKind;
  type: string;
  description: string;
  status: string | number;
  isSuccess: boolean;
}

type RawRouteInfo = {
  operationId: string;
  method: string;
  route: string;
  moduleName: string;
  responsesTypes: RequestResponseInfo[];
  description?: string;
  tags?: string[];
  summary?: string;
  responses?: swagger_schema_official.Spec["responses"];
  produces?: string[];
  requestBody?: object;
  consumes?: string[];
};

interface ParsedRoute {
  id: string;
  jsDocLines: string;
  namespace: string;
  request: Request;
  response: Response;
  routeName: RouteNameInfo;
  raw: RawRouteInfo;
}

type ModelType = {
  typeIdentifier: string;
  name: string;
  rawContent: string;
  description: string;
  content: string;
};

declare enum SCHEMA_TYPES {
  ARRAY = "array",
  OBJECT = "object",
  ENUM = "enum",
  REF = "$ref",
  PRIMITIVE = "primitive",
  COMPLEX = "complex",
  COMPLEX_ONE_OF = "oneOf",
  COMPLEX_ANY_OF = "anyOf",
  COMPLEX_ALL_OF = "allOf",
  COMPLEX_NOT = "not",
  COMPLEX_UNKNOWN = "__unknown",
}

type MAIN_SCHEMA_TYPES =
  | SCHEMA_TYPES.PRIMITIVE
  | SCHEMA_TYPES.OBJECT
  | SCHEMA_TYPES.ENUM;

type ExtractingOptions = {
  requestBodySuffix: string[];
  responseBodySuffix: string[];
  responseErrorSuffix: string[];
  requestParamsSuffix: string[];
  enumSuffix: string[];
  discriminatorMappingSuffix: string[];
  discriminatorAbstractPrefix: string[];
  requestBodyNameResolver: (
    name: string,
    reservedNames: string,
  ) => string | undefined;
  responseBodyNameResolver: (
    name: string,
    reservedNames: string,
  ) => string | undefined;
  responseErrorNameResolver: (
    name: string,
    reservedNames: string,
  ) => string | undefined;
  requestParamsNameResolver: (
    name: string,
    reservedNames: string,
  ) => string | undefined;
  enumNameResolver: (name: string, reservedNames: string) => string | undefined;
  discriminatorMappingNameResolver: (
    name: string,
    reservedNames: string,
  ) => string | undefined;
  discriminatorAbstractResolver: (
    name: string,
    reservedNames: string,
  ) => string | undefined;
};

interface GenerateApiConfiguration {
  apiConfig: {
    baseUrl: string;
    title: string;
    version: string;
    description: string[];
    hasDescription: boolean;
  };
  config: {
    input: string;
    output: string;
    url: string;
    spec: unknown;
    fileName: string;
    templatePaths: {
      /** `templates/base` */
      base: string;
      /** `templates/default` */
      default: string;
      /** `templates/modular` */
      modular: string;
      /** usage path if `--templates` option is not set */
      original: string;
      /** custom path to templates (`--templates`) */
      custom: string | null;
    };
    authorizationToken?: string;
    generateResponses: boolean;
    defaultResponseAsSuccess: boolean;
    generateRouteTypes: boolean;
    generateClient: boolean;
    generateUnionEnums: boolean;
    swaggerSchema: object;
    originalSchema: object;
    componentsMap: Record<string, SchemaComponent>;
    convertedFromSwagger2: boolean;
    moduleNameIndex: number;
    moduleNameFirstTag: boolean;
    extraTemplates: { name: string; path: string }[];
    disableStrictSSL: boolean;
    disableProxy: boolean;
    extractRequestParams: boolean;
    unwrapResponseData: boolean;
    sortTypes: boolean;
    sortRoutes: boolean;
    singleHttpClient: boolean;
    typePrefix: string;
    typeSuffix: string;
    enumKeyPrefix: string;
    enumKeySuffix: string;
    patch: boolean;
    cleanOutput: boolean;
    debug: boolean;
    anotherArrayType: boolean;
    extractRequestBody: boolean;
    httpClientType: "axios" | "fetch";
    addReadonly: boolean;
    extractResponseBody: boolean;
    extractResponseError: boolean;
    extractEnums: boolean;
    fixInvalidTypeNamePrefix: string;
    fixInvalidEnumKeyPrefix: string;
    defaultResponseType: string;
    toJS: boolean;
    disableThrowOnError: boolean;
    silent: boolean;
    hooks: Hooks;
    enumNamesAsValues: boolean;
    version: string;
    compilerTsConfig: Record<string, unknown>;
    enumKeyResolverName: string;
    typeNameResolverName: string;
    specificArgNameResolverName: string;
    /** do not use constructor args, it can break functionality of this property, just send class reference */
    customTranslator?: new (
      ...args: never[]
    ) => typeof Translator;
    internalTemplateOptions: {
      addUtilRequiredKeysType: boolean;
    };
    componentTypeNameResolver: typeof ComponentTypeNameResolver;
    fileNames: {
      dataContracts: string;
      routeTypes: string;
      httpClient: string;
      outOfModuleApi: string;
    };
    templatesToRender: {
      api: string;
      dataContracts: string;
      httpClient: string;
      routeTypes: string;
      routeName: string;
      dataContractJsDoc: string;
      interfaceDataContract: string;
      typeDataContract: string;
      enumDataContract: string;
      objectFieldJsDoc: string;
    };
    routeNameDuplicatesMap: Map<string, string>;
    apiClassName: string;
    requestOptions?: RequestInit;
    extractingOptions: ExtractingOptions;
  };
  modelTypes: ModelType[];
  hasFormDataRoutes: boolean;
  hasSecurityRoutes: boolean;
  hasQueryRoutes: boolean;
  generateResponses: boolean;
  routes: {
    outOfModule: ParsedRoute[];
    combined?: {
      moduleName: string;
      routes: ParsedRoute[];
    }[];
  };
  requestOptions?: null | Partial<RequestInit>;
  utils: {
    formatDescription: (description: string, inline?: boolean) => string;
    internalCase: (value: string) => string;
    /** @deprecated */
    classNameCase: (value: string) => string;
    pascalCase: (value: string) => string;
    getInlineParseContent: (
      rawTypeData: SchemaComponent["rawTypeData"],
      typeName?: string,
    ) => string;
    getParseContent: (
      rawTypeData: SchemaComponent["rawTypeData"],
      typeName?: string,
    ) => ModelType;
    getComponentByRef: (ref: string) => SchemaComponent;
    parseSchema: (
      rawSchema: string | SchemaComponent["rawTypeData"],
      typeName?: string,
      formattersMap?: Record<MAIN_SCHEMA_TYPES, (content: ModelType) => string>,
    ) => ModelType;
    formatters: Record<
      MAIN_SCHEMA_TYPES,
      (content: string | object | string[] | object[]) => string
    >;
    inlineExtraFormatters: Record<
      Exclude<MAIN_SCHEMA_TYPES, SCHEMA_TYPES.PRIMITIVE>,
      (schema: ModelType) => string
    >;
    formatModelName: (name: string) => string;
    fmtToJSDocLine: (line: string, params?: { eol?: boolean }) => string;
    _: lodash.LoDashStatic;
    require: (path: string) => unknown;
  };
}

type FileInfo = {
  /** @example myFilename */
  fileName: string;
  /** @example .d.ts */
  fileExtension: string;
  /** content of the file */
  fileContent: string;
};

interface GenerateApiOutput {
  configuration: GenerateApiConfiguration;
  files: FileInfo[];
  createFile: (params: {
    path: string;
    fileName: string;
    content: string;
    withPrefix?: boolean;
  }) => void;
  renderTemplate: (
    templateContent: string,
    data: Record<string, unknown>,
    etaOptions?: Partial<eta.EtaConfig>,
  ) => string;
  getTemplate: (params: {
    fileName?: string;
    name?: string;
    path?: string;
  }) => string;
  formatTSContent: (content: string) => Promise<string>;
}

declare function generateApi(
  params: GenerateApiParams,
): Promise<GenerateApiOutput>;

interface GenerateTemplatesParams {
  cleanOutput?: boolean;
  output?: string;
  httpClientType?: HttpClientType;
  modular?: boolean;
  silent?: boolean;
}

interface GenerateTemplatesOutput
  extends Pick<GenerateApiOutput, "files" | "createFile"> {}

declare function generateTemplates(
  params: GenerateTemplatesParams,
): Promise<GenerateTemplatesOutput>;

export { type GenerateApiConfiguration, type GenerateApiOutput, type GenerateApiParams, type GenerateTemplatesOutput, type GenerateTemplatesParams, type Hooks, type ModelType, type ParsedRoute, type ParsedSchema, type PathArgInfo, type RawRouteInfo, RequestContentKind, type RequestResponseInfo, type RouteNameInfo, type RouteNameRouteInfo, SCHEMA_TYPES, type SchemaComponent, type SchemaTypeEnumContent, type SchemaTypeObjectContent, type SchemaTypePrimitiveContent, generateApi, generateTemplates };
